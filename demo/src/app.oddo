// Oddo Language Demo
// Written in Oddo, compiled to JS

import { mount, e } from "@oddo/ui"
import { highlightOddo } from "@oddo/lang"
import { highlight as highlightJS } from "best-highlight"

// Guide Page Component
GuidePage = () => {
  atSign = "@"

  code1 = `Counter = () => {
  @state count = 0
  @mutate increment = () => {
    count := count + 1
  }
  return <button onclick={increment}>
    Count: {count}
  </button>
}`

  code2 = `@mutable x = 10               // bind x to 10
@mutate increment = () => {   // mutations are constranined to mutator functions
  x := x + 1                  // mutate x to 11
}`

  code3 = `@state name = "World"
@computed greeting = "Hello, " + name + "!"
@effect () => console.log(greeting)`

  code4 = `<div class="card">
  <h2>{title}</h2>
  <p>Dynamic content: {value}</p>
  <Button onclick={handler}>Click</Button>
</div>`

  code5 = `import { mount } from "@oddo/ui"

App = () => <h1>Hello, Oddo!</h1>

mount(document.body, <App />)`

  return <div class="doc-page">
    <div class="doc-content">
      <section class="doc-hero">
        <h1>Welcome to Oddo</h1>
        <p class="doc-lead">A functional reactive programing language.</p>
      </section>

      <section class="doc-section">
        <h2>What is Oddo?</h2>
        <p>Oddo is an experimental language intended for reactive programming. It is a JavaScript dialect that treats reactivity as a first-class language primitive and places a stronger emphasis on data immutability.</p>
        <p>Oddo ships with its own UI rendering library for fine-grained reactivity and built-in JSX support.</p>
      </section>

      <section class="doc-section">
        <h2>Key Differentiators</h2>

        <div class="doc-feature">
          <h3>Arrow Function Components</h3>
          <p>Components are simple arrow functions. Reactive state and mutations are declared inline with modifiers.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(code1) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Mutation with :=</h3>
          <p>Oddo distinguishes binding (=) from mutation (:=). This makes state changes explicit and predictable.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(code2) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>{atSign} Modifiers</h3>
          <p>Reactive primitives use the {atSign} prefix for clarity. At a glance, you know what is reactive.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(code3) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>JSX-First UI</h3>
          <p>JSX is a first-class citizen. Build reactive interfaces naturally with familiar syntax.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(code4) })}</pre>
        </div>
      </section>

      <section class="doc-section">
        <h2>Hello World</h2>
        <p>Here is the simplest Oddo application:</p>
        <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(code5) })}</pre>
        <p>That is it. No boilerplate, no configuration. Just write and run.</p>
      </section>

      <section class="doc-section">
        <h2>Ready to Explore?</h2>
        <p>Head to the <strong>API</strong> tab to learn about all the features, or jump into the <strong>Playground</strong> to start writing code immediately.</p>
      </section>
    </div>
  </div>
}

// API Page Component
APIPage = () => {
  atSign = "@"

  codeState = `@state count = 0
@state items = []
@state user = { name: "Alice", age: 30 }`

  codeComputed = `@state a = 5
@state b = 3
@computed sum = a + b
@computed doubled = sum * 2`

  codeEffect = `@effect () => console.log("Count:", count)
@effect () => localStorage.setItem("count", count)`

  codeMutate = `@mutate increment = () => {
  count := count + 1
}
@mutate updateUser = (name) => {
  user.name := name
}`

  codeOps = `=     Binding (declaration)      x = 10
:=    Mutation (reassignment)    x := 20
+:=   Add and mutate             x +:= 5
-:=   Subtract and mutate        x -:= 3`

  codeEquality = `5 == 5      // true (compiles to ===)
5 == "5"    // false (strict comparison)
null == null // true`

  codeAllOps = `// Arithmetic
a + b, a - b, a * b, a / b, a % b, a ** b

// Comparison
a < b, a > b, a <= b, a >= b, a == b, a != b

// Logical
a && b, a || b, !a

// Ternary
condition ? valueIfTrue : valueIfFalse`

  codePrimitives = `42              // number
3.14            // number (float)
"hello"         // string
true, false     // boolean
null            // null`

  codeArrays = `[1, 2, 3]
["a", "b", "c"]
[1, "mixed", true, null]`

  codeObjects = `{ name: "Alice", age: 30 }
{ x: 1, y: 2 }
{ name }           // shorthand
{ [key]: value }   // computed property`

  codeArrows = `x => x + 1
(a, b) => a + b
() => 42
(x) => { return x * 2 }`

  codeElements = `<div>Hello</div>
<Button />
<MyComponent prop="value" />`

  codeAttrs = `<div class="container">...</div>
<input value={inputValue} />
<button onclick={handleClick}>Click</button>
<div {...props} />`

  codeNesting = `<div>
  <h1>Title</h1>
  <p>Static text and dynamic content</p>
  <List items={items} />
</div>`

  codeBlock = `Component = () => {
  @state value = 0

  @mutate setValue = (v) => {
    value := v
  }

  return <div onclick={() => { setValue(10) }}>
    Value: {value}
  </div>
}`

  return <div class="doc-page">
    <div class="doc-content">
      <section class="doc-hero">
        <h1>API Reference</h1>
        <p class="doc-lead">Complete documentation of Oddo reactive primitives, operators, and syntax.</p>
      </section>

      <section class="doc-section">
        <h2>Reactive Primitives</h2>

        <div class="doc-feature">
          <h3>{atSign}state</h3>
          <p>Declares reactive state. When state changes, dependent UI automatically updates.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeState) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>{atSign}computed</h3>
          <p>Derives values from state. Automatically recalculates when dependencies change.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeComputed) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>{atSign}effect</h3>
          <p>Runs side effects when dependencies change. Perfect for logging, API calls, or DOM manipulation.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeEffect) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>{atSign}mutate</h3>
          <p>Defines mutation functions that can safely modify state. Enables batched updates.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeMutate) })}</pre>
        </div>
      </section>

      <section class="doc-section">
        <h2>Operators</h2>

        <div class="doc-feature">
          <h3>Assignment vs Mutation</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeOps) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Equality</h3>
          <p>Oddo simplifies equality: == always compiles to JavaScript === (strict equality). No type coercion surprises.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeEquality) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>All Standard Operators</h3>
          <p>Arithmetic, logical, comparison, and bitwise operators work as expected.</p>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeAllOps) })}</pre>
        </div>
      </section>

      <section class="doc-section">
        <h2>Data Types</h2>

        <div class="doc-feature">
          <h3>Primitives</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codePrimitives) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Arrays</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeArrays) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Objects</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeObjects) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Arrow Functions</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeArrows) })}</pre>
        </div>
      </section>

      <section class="doc-section">
        <h2>JSX Syntax</h2>

        <div class="doc-feature">
          <h3>Elements and Components</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeElements) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Attributes and Expressions</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeAttrs) })}</pre>
        </div>

        <div class="doc-feature">
          <h3>Children and Nesting</h3>
          <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeNesting) })}</pre>
        </div>
      </section>

      <section class="doc-section">
        <h2>Component Structure</h2>
        <p>Components are arrow functions with curly braces. State, mutations, and the return statement go inside:</p>
        <pre class="doc-code-block">{e("code", { innerHTML: highlightOddo(codeBlock) })}</pre>
      </section>
    </div>
  </div>
}

// Playground Component (unchanged)
Playground = () => {
  @state input = ""
  @state output = "// Output will appear here..."
  @state outputMode = "js"
  @state hasError = false
  @state parseTime = "--"
  @state nodeCount = "--"
  @state outputSize = "--"
  @state lastAST = null
  @state lastJS = null

  // Mutations for state updates
  @mutate updateInput = (value) => {
    input := value
  }

  @mutate updateOutput = (value) => {
    output := value
  }

  @mutate updateOutputMode = (value) => {
    outputMode := value
  }

  @mutate updateHasError = (value) => {
    hasError := value
  }

  @mutate updateParseTime = (value) => {
    parseTime := value
  }

  @mutate updateNodeCount = (value) => {
    nodeCount := value
  }

  @mutate updateOutputSize = (value) => {
    outputSize := value
  }

  @mutate updateLastAST = (value) => {
    lastAST := value
  }

  @mutate updateLastJS = (value) => {
    lastJS := value
  }

  // Compile function
  doCompile = () => {
    code = input
    code.trim() == "" ? showEmpty() : sendCompile(code)
  }

  showEmpty = () => {
    outputEl = document.getElementById("output-area")
    outputEl ? outputEl.textContent := "// No input" : null
    updateHasError(false)
    updateParseTime("--")
    updateNodeCount("--")
    updateOutputSize("--")
  }

  sendCompile = (code) => {
    startTime = performance.now()
    fetch("/compile", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ code: code })
    })
    .then((res) => res.json())
    .then((result) => handleResult(result, startTime))
    .catch((err) => handleError(err.message))
  }

  handleResult = (result, startTime) => {
    elapsed = Math.round(performance.now() - startTime)
    result.error ? handleError(result.error) : handleSuccess(result, elapsed)
  }

  handleSuccess = (result, elapsed) => {
    updateHasError(false)
    updateLastAST(result.ast)
    updateLastJS(result.js)
    updateParseTime(elapsed + "ms")
    updateNodeCount(countNodes(result.ast))
    updateOutputSize(result.js.length + " B")
    showOutput()
  }

  handleError = (msg) => {
    updateHasError(true)
    outputEl = document.getElementById("output-area")
    outputEl ? outputEl.textContent := "// Error: " + msg : null
    updateParseTime("error")
    updateNodeCount("--")
    updateOutputSize("--")
  }

  showOutput = () => {
    mode = outputMode
    outputEl = document.getElementById("output-area")
    mode == "js" ? showJSOutput(outputEl) : showASTOutput(outputEl)
  }

  showJSOutput = (el) => {
    el ? el.innerHTML := highlightJS(String(lastJS), "javascript") : null
  }

  showASTOutput = (el) => {
    astStr = JSON.stringify(lastAST, null, 2)
    el ? el.textContent := astStr : null
  }

  countNodes = (obj) => {
    obj == null ? 0 : typeof obj != "object" ? 0 : Object.keys(obj).reduce((sum, k) => sum + countNodes(obj[k]), 1)
  }

  // Load example
  loadExample = (name) => {
    name == "" ? null : fetchExample(name)
  }

  fetchExample = (name) => {
    fetch("/examples/" + name + ".oddo")
    .then((res) => res.text())
    .then((code) => {
      updateInput(code)
      syncHighlightFromCode(code)
      document.getElementById("input-area").value := code
      doCompile()
    })
  }

  // Toggle output mode
  toggleMode = (mode) => {
    updateOutputMode(mode)
    lastJS ? showOutput() : null
  }

  // Run in preview
  runPreview = () => {
    js = lastJS
    js ? executePreview(js) : null
  }

  executePreview = (js) => {
    frame = document.getElementById("preview-frame")
    fetch("/preview", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ js: js })
    })
    .then((res) => res.text())
    .then((html) => {
      frame.srcdoc := html
    })
  }

  // Handle input changes with debounce
  debounce = { timer: null }
  handleInputEvent = (value) => {
    updateInput(value)
    syncHighlightFromCode(value)
    debounce.timer ? clearTimeout(debounce.timer) : null
    debounce.timer := setTimeout(doCompile, 300)
  }

  syncHighlightFromCode = (codeStr) => {
    el = document.getElementById("highlight-layer")
    el ? setInnerHTML(el, highlightOddo(String(codeStr)) + " ") : null
  }

  setInnerHTML = (element, html) => {
    element.innerHTML := html
  }

  handleScrollEvent = (textarea) => {
    highlight = document.getElementById("highlight-layer")
    highlight ? syncScroll(highlight, textarea) : null
  }

  syncScroll = (highlight, textarea) => {
    highlight.scrollTop := textarea.scrollTop
    highlight.scrollLeft := textarea.scrollLeft
  }

  handleKeyDownEvent = (e) => {
    (e.ctrlKey || e.metaKey) && e.key == "Enter" ? doRunPreview(e) : null
  }

  doRunPreview = (e) => {
    e.preventDefault()
    runPreview()
  }

  return <div class="playground-layout">
    <div class="editor-row">
      <div class="panel">
        <div class="panel-header">
          <h3>Input</h3>
          <select onchange={(e) => { loadExample(e.target.value) }}>
            <option value="">Load example...</option>
            <option value="counter">Counter</option>
            <option value="computed">Computed</option>
            <option value="primitives">Primitives</option>
            <option value="operators">Operators</option>
            <option value="jsx">JSX</option>
            <option value="modifiers">Modifiers</option>
          </select>
        </div>
        <div class="panel-content">
          <div class="editor-container">
            <pre id="highlight-layer" class="editor-highlight"></pre>
            <textarea
              id="input-area"
              class="editor-textarea"
              oninput={(e) => { handleInputEvent(e.target.value) }}
              onkeydown={(e) => { handleKeyDownEvent(e) }}
              onscroll={(e) => { handleScrollEvent(e.target) }}
              placeholder="// Write Oddo code here..."
              spellcheck="false"
            ></textarea>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h3>Output</h3>
          <div class="output-toggle">
            <button
              class={outputMode == "js" ? "active" : ""}
              onclick={() => { toggleMode("js") }}
            >JS</button>
            <button
              class={outputMode == "ast" ? "active" : ""}
              onclick={() => { toggleMode("ast") }}
            >AST</button>
          </div>
        </div>
        <div class="panel-content">
          <div id="output-area" class={hasError ? "output-area error" : "output-area"}>{output}</div>
        </div>
        <div class="stats-bar">
          <span>Parse: {parseTime}</span>
          <span>Nodes: {nodeCount}</span>
          <span>Size: {outputSize}</span>
        </div>
      </div>
    </div>

    <div class="preview-section">
      <div class="preview-header">
        <h3>Preview</h3>
        <button class="run-btn" onclick={runPreview}>Run</button>
      </div>
      <div class="preview-content">
        <iframe id="preview-frame" sandbox="allow-scripts"></iframe>
      </div>
    </div>
  </div>
}

// Main App Component
App = () => {
  @state currentPage = "guide"

  @mutate setPage = (page) => {
    currentPage := page
  }

  return <div class="layout">
    <header>
      <div class="logo">&lt;oddo/&gt;</div>
      <div class="divider"></div>
      <nav class="nav-tabs">
        <button
          class={currentPage == "guide" ? "nav-tab active" : "nav-tab"}
          onclick={() => { setPage("guide") }}
        >Guide</button>
        <button
          class={currentPage == "api" ? "nav-tab active" : "nav-tab"}
          onclick={() => { setPage("api") }}
        >API</button>
        <button
          class={currentPage == "playground" ? "nav-tab active" : "nav-tab"}
          onclick={() => { setPage("playground") }}
        >Playground</button>
      </nav>
    </header>
    <main class="main-content">
      {currentPage == "guide" ? <GuidePage /> : currentPage == "api" ? <APIPage /> : <Playground />}
    </main>
  </div>
}

// Mount the app
mount(document.getElementById("app"), <App />)
